<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Desktop Mascot</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent; /* 背景透過 */
      }

      canvas {
        display: block;
        background: transparent;
      }
    </style>
    <script type="importmap">{
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
      }
    }
    </script>
  </head>
  <body>
    <script type ="module">
      // オフラインじゃ動かないので注意
      import * as THREE from 'three';
      import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
      import { MMDAnimationHelper } from 'three/addons/animation/MMDAnimationHelper.js';

      // URLのクエリパラメータから .pmx .pmd を取得
      const url        = new URL(window.location.href);
      const modelPath  = url.searchParams.get('modelPath');
      const vmdPath    = url.searchParams.get('vmdPath');
      console.log('modelPath:', modelPath);
      console.log('vmdPath  :', vmdPath);

      const width = window.innerWidth;
      const height = window.innerHeight;

      const scene = new THREE.Scene();

      // カメラ設定
      const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
      camera.position.set(0, 17, 10);  // (x軸, y軸, カメラ距離)

      // レンダラー設定
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true, // キャンバス背景透明
      });
      renderer.setSize(width, height);
      renderer.setClearColor(0x000000, 0); // 完全透明
      document.body.appendChild(renderer.domElement);

      // 見た目調整用（白飛び調整）
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.4;

      // スポットライト設定
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
      dirLight.position.set(0, 20, 20);
      scene.add(dirLight);

      // 環境光設定
      const ambient = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambient);

      // PMX 読み込み
      const loader = new MMDLoader();
      // pmd 読み込み
      const helper = new MMDAnimationHelper({
        afterglow: 2.0,  // モーション間の補正
        physics: false,  // 物理演算
      });

      // 各種パス
      //const modelPath = 'models/hoge.pmx';
      //const vmdPath = 'motions/hoge.vmd';
        
      let model = null;

      loader.load(
        modelPath,
        (mesh) => {
        model = mesh;

        // モデルの調整（カメラ設定でいじったほうがいいと思う）
        //model.position.y = -10;
        //model.rotation.y = Math.PI;

        scene.add(model);
        console.log('PMX 読み込み完了');

        if (vmdPath) {
          loader.loadAnimation(  // (path, model, onLoad, onProgress, onError)
          vmdPath,
          model,
          (animation) => {
            helper.add(model, {
              animation,
              physics: false,  // ここでも宣言しないと動かないっぽい？
            });
            console.log('モーション(VMD) 読み込み完了');
          },
          undefined,
          (error) => {
            console.error('モーション読み込みエラー:', error);
          }
          );
        }
        },
        undefined,
        (error) => {
          console.error('PMX 読み込みエラー:', error);
        }
      );

      // アニメーション
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        helper.update(delta);  // モーション再生
        renderer.render(scene, camera);
      }

      animate();

      // ウィンドウリサイズ対応
      window.addEventListener("resize", () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    </script>
  </body>
</html>
